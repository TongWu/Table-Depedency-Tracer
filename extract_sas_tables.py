#!/usr/bin/env python3
"""Extract input/output tables from SAS DI generated scripts.

The parser understands the macro definitions generated by SAS Data Integration
Studio jobs. It locates ``_INPUT``/``_OUTPUT`` macro assignments together with
``_OUTPUT*_col*_input*_table`` metadata to recover the relationship between the
upstream (source) and downstream (target) tables.

Example usage::

    $ python extract_sas_tables.py Test_Files/POPULATE_ALL_TARGET_T_ADM_PR_RFD_IIT.sas

"""

from __future__ import annotations

import argparse
import re
import sys
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Mapping, Sequence, Set

# ---------------------------------------------------------------------------
# Data structures
# ---------------------------------------------------------------------------


@dataclass
class TableSummary:
    """Stores lineage information for a single SAS script."""

    path: Path
    inputs: Sequence[str]
    outputs: Mapping[str, Sequence[str]]  # output table -> list of source tables


# ---------------------------------------------------------------------------
# Parsing helpers
# ---------------------------------------------------------------------------


RE_MACRO_ASSIGN = re.compile(r"%let\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*([^;]*);", re.IGNORECASE)


def iter_sas_files(paths: Sequence[str]) -> List[Path]:
    """Return a sorted list of ``.sas`` files contained in ``paths``."""

    files: Set[Path] = set()
    for raw in paths:
        p = Path(raw)
        if p.is_dir():
            files.update(path for path in p.rglob("*.sas") if path.is_file())
        elif p.is_file():
            if p.suffix.lower() == ".sas":
                files.add(p)
        else:
            raise FileNotFoundError(f"Path not found: {p}")
    return sorted(files)


def _sanitize_macro_value(value: str) -> str:
    """Trim surrounding quotes and whitespace."""

    v = value.strip()
    if (v.startswith("'") and v.endswith("'")) or (v.startswith('"') and v.endswith('"')):
        v = v[1:-1]
    return v.strip()


def parse_macros(text: str) -> Dict[str, str]:
    """Return macro assignments keyed by lower-case macro names."""

    macros: Dict[str, str] = {}
    for match in RE_MACRO_ASSIGN.finditer(text):
        name = match.group(1).lower()
        value = _sanitize_macro_value(match.group(2))
        macros[name] = value
    return macros


def normalize_dataset(value: str) -> str:
    """Return a canonical representation of a SAS dataset name."""

    cleaned = value.strip()
    cleaned = cleaned.rstrip(";,)")
    cleaned = cleaned.lstrip("(")
    return cleaned


def extract_summary(path: Path) -> TableSummary:
    """Parse ``path`` and return the lineage summary."""

    text = path.read_text(encoding="utf-8", errors="ignore")
    macros = parse_macros(text)

    seen_inputs: Set[str] = set()
    inputs: List[str] = []
    for name, value in macros.items():
        if re.fullmatch(r"_input\d*", name):
            dataset = normalize_dataset(value)
            key = dataset.lower()
            if dataset and key not in seen_inputs:
                seen_inputs.add(key)
                inputs.append(dataset)

    output_tables: Dict[str, str] = {}
    for name, value in macros.items():
        if re.fullmatch(r"_output\d*", name):
            dataset = normalize_dataset(value)
            if dataset:
                output_tables[name] = dataset

    output_sources: Dict[str, Set[str]] = defaultdict(set)
    for name, value in macros.items():
        match = re.fullmatch(r"(_output\d*)_col\d+_input\d+_table", name)
        if match:
            prefix = match.group(1)
            dataset = normalize_dataset(value)
            if dataset:
                output_sources[prefix].add(dataset)

    combined: Dict[str, Set[str]] = defaultdict(set)
    for prefix, table in output_tables.items():
        combined[table].update(output_sources.get(prefix, set()))

    outputs: Dict[str, Sequence[str]] = {}
    for table, sources in combined.items():
        outputs[table] = sorted(sources)

    return TableSummary(path=path, inputs=inputs, outputs=outputs)


# ---------------------------------------------------------------------------
# Rendering helpers
# ---------------------------------------------------------------------------


def render_summary(summary: TableSummary) -> str:
    rel_path = summary.path.as_posix()
    lines = [f"=== {rel_path} ===", "Input Tables:"]
    if summary.inputs:
        lines.extend(f"    - {tbl}" for tbl in summary.inputs)
    else:
        lines.append("    (none detected)")

    lines.append("Output Tables:")
    if summary.outputs:
        for output, sources in summary.outputs.items():
            lines.append(f"    - {output}")
            if sources:
                lines.extend(f"        Source: {src}" for src in sources)
            else:
                lines.append("        Source: (no explicit mapping detected)")
    else:
        lines.append("    (none detected)")
    return "\n".join(lines)


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------


def main(argv: Sequence[str]) -> int:
    parser = argparse.ArgumentParser(description="Extract input/output tables from SAS scripts")
    parser.add_argument("paths", nargs="+", help="SAS file(s) or directories to scan")
    args = parser.parse_args(argv)

    try:
        files = iter_sas_files(args.paths)
    except FileNotFoundError as exc:
        print(str(exc), file=sys.stderr)
        return 1

    if not files:
        print("No SAS files found in the provided paths.", file=sys.stderr)
        return 1

    for path in files:
        summary = extract_summary(path)
        print(render_summary(summary))
        print()

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
